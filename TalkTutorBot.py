from typing import Dict
from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove, Update, InlineKeyboardButton, InlineKeyboardMarkup
import logging
from telegram.ext import (CommandHandler, MessageHandler, filters,  Application,
                           ContextTypes, ConversationHandler, CallbackQueryHandler, CallbackContext)
from googletrans import Translator
from telegram.constants import ParseMode
import random

import os
from dotenv import load_dotenv
load_dotenv()

import tracemalloc
tracemalloc.start()


# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)


CHOOSING, TYPING_REPLY, TYPING_CHOICE = range(3)

RESPUESTA = 5

reply_keyboard = [
    ["Gram√°tica", "Vocabulario b√°sico"],
    ["Pr√°ctica", "Recursos adicionales"],
    ["Done"],
]
markup = ReplyKeyboardMarkup(reply_keyboard, one_time_keyboard=True)

async def start(update, context: ContextTypes.DEFAULT_TYPE):

    if update.message:
        await update.message.reply_text("Hola! ¬øEn qu√© puedo ayudarte?",
                    reply_markup=markup)

    elif update.callback_query:
        query = update.callback_query
        await query.answer()
        await query.edit_message_text("Hola! ¬øEn qu√© puedo ayudarte?")
    return CHOOSING

def facts_to_str(user_data: Dict[str, str]) -> str:
    """Helper function for formatting the gathered user info."""
    facts = [f"{key} - {value}" for key, value in user_data.items()]
    return "\n".join(facts).join(["\n", "\n"])

async def vocabulario(update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton("Hola", callback_data="hola"),
            InlineKeyboardButton("Buenos d√≠as", callback_data="Buenos d√≠as"),
            InlineKeyboardButton("Disculpa", callback_data="Disculpa"),
            InlineKeyboardButton("¬°Genial!", callback_data="¬°Genial!"),
        ],
        [InlineKeyboardButton("¬øQu√© hora es?", callback_data="¬øQu√© hora es?")],
        [InlineKeyboardButton("¬øEn qu√© puedo ayudarte?", callback_data="¬øEn qu√© puedo ayudarte?")],
        [InlineKeyboardButton("Inteligencia artificial", callback_data="Inteligencia artificial")],
        [InlineKeyboardButton("¬øPodr√≠as repetir eso, por favor?", callback_data="¬øPodr√≠as repetir eso, por favor?")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text("Empecemos. ¬øQu√© palabra te gustar√≠a aprender hoy? Puedes escribir la palabra o seleccionarla de la lista:"
        ,reply_markup = reply_markup)


async def vocabulario_options(update, context):
    query = update.callback_query
    await query.answer()
    option_selected = query.data

    # Llamar a la funci√≥n "selected_option" para manejar la selecci√≥n del usuario
    next_state = await vocabulario_selected_option(update, context, option_selected)

    return next_state

def traductor(option):
    # Crear un objeto Translator
    translator = Translator()

    # Traducir el texto al ingl√©s
    translated_text = translator.translate(str(option), src="es", dest="en")

    return translated_text

async def vocabulario_selected_option(update, context, option_selected):

    #Invocamos m√©todo para traducir:
    translated_text = traductor(option_selected)

    # Responder al usuario con la traducci√≥n
    await update.callback_query.edit_message_text(
        text=f"La palabra que seleccionaste se traduce como: {translated_text.text}"
    )

    # Enviar el mensaje del men√∫ principal
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        await context.bot.send_message(
            chat_id=query.message.chat_id,
            text="Hola! ¬øEn qu√© puedo ayudarte?",
            reply_markup=markup
        )

    # Retornar al men√∫ principal
    return CHOOSING


async def gramatica(update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton(text="Uso de verbos regulares e irregulares", callback_data="verbos")],
        [InlineKeyboardButton(text="Uso de adjetivos", callback_data="adjetivos")],
        [InlineKeyboardButton(text="Uso de pronombres", callback_data="pronombres")],
        [InlineKeyboardButton(text="Uso de preposiciones", callback_data="preposiciones")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Seleccione una opci√≥n para conocer m√°s acerca de la gram√°tica:", reply_markup=reply_markup)


async def gramatica_options(update, context):
    query = update.callback_query
    await query.answer()
    option_selected = query.data

    # Llamar a la funci√≥n "selected_option" para manejar la selecci√≥n del usuario
    next_state = await gramatica_selected_option(update, context, option_selected)

    return next_state

async def gramatica_selected_option(update, context, option_selected):
    text = "Retornando"
    if option_selected == "verbos":
        text = "Los verbos en ingl√©s se utilizan para expresar acciones, estados o procesos. Hay dos tipos de verbos: regulares e irregulares. Los verbos regulares forman el pasado y participio pasado a√±adiendo -ed al infinitivo, mientras que los verbos irregulares tienen formas especiales que no siguen este patr√≥n. Algunos ejemplos de verbos regulares son walked (camin√≥), talked (habl√≥), played (jug√≥), mientras que algunos ejemplos de verbos irregulares son go (ir), eat (comer), swim (nadar)."
    elif option_selected == "adjetivos":
        text = "Los adjetivos en ingl√©s se utilizan para describir o calificar a los sustantivos. Normalmente, los adjetivos se colocan antes del sustantivo que modifican. Algunos ejemplos de adjetivos en ingl√©s son happy (feliz), sad (triste), big (grande), small (peque√±o)."
    elif option_selected == "pronombres":
        text = "Los pronombres en ingl√©s se utilizan en lugar de los sustantivos para evitar repetir los mismos nombres una y otra vez. Algunos ejemplos de pronombres en ingl√©s son I (yo), you (t√∫), he (√©l), she (ella), we (nosotros), they (ellos)."
    elif option_selected == "preposiciones":
        text = "Las preposiciones en ingl√©s se utilizan para establecer relaciones entre sustantivos, pronombres y otras palabras en una oraci√≥n. Algunos ejemplos de preposiciones en ingl√©s son in (en), on (sobre), under (debajo), above (encima), below (debajo)."
    elif option_selected == "menu":
        # Si se selecciona la opci√≥n "Volver al men√∫ principal", se llama a la funci√≥n start
       text = "Menu principal"
       
    else:
        # Si se selecciona una opci√≥n inv√°lida, mostrar un mensaje de error
        text = "Lo siento, opci√≥n inv√°lida. Por favor, selecciona una opci√≥n v√°lida."
    # Responder al usuario con el texto en espa√±ol
    await update.callback_query.edit_message_text(
        text=f"{text}"
    )

    if text == "Menu principal":
        if update.callback_query:
            query = update.callback_query
            await query.answer()
            await context.bot.send_message(
                chat_id=query.message.chat_id,
                text="Hola! ¬øEn qu√© puedo ayudarte?",
                reply_markup=markup
            )
    else:

    # Enviar el mensaje del men√∫ principal
        if update.callback_query:
            query = update.callback_query
            await query.answer()
            keyboard = [
                [InlineKeyboardButton(text="Uso de verbos regulares e irregulares", callback_data="verbos")],
                [InlineKeyboardButton(text="Uso de adjetivos", callback_data="adjetivos")],
                [InlineKeyboardButton(text="Uso de pronombres", callback_data="pronombres")],
                [InlineKeyboardButton(text="Uso de preposiciones", callback_data="preposiciones")],
                [InlineKeyboardButton(text="Volver al men√∫ principal", callback_data="menu")],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="Selecciona una opci√≥n:",
                reply_markup=reply_markup
            )
    return CHOOSING

async def practica(update, context):
    # Definir una lista de preguntas y respuestas en formato (pregunta, respuesta)
    preguntas_respuestas = [
        ("¬øC√≥mo se dice 'hola' en ingl√©s?", "hello"),
        ("¬øC√≥mo se dice 'buenos d√≠as' en ingl√©s?", "good morning"),
        ("Traduce 'perro' al ingl√©s", "dog"),
        ("Traduce 'gato' al ingl√©s", "cat"),
        ("¬øC√≥mo se dice 'adi√≥s' en ingl√©s?", "goodbye"),
        ("¬øC√≥mo se dice 'buenas tardes' en ingl√©s?", "good afternoon"),
    ]

    # Elegir aleatoriamente una pregunta y su respuesta
    pregunta, respuesta = random.choice(preguntas_respuestas)

    # Guardar la respuesta correcta en el contexto
    context.user_data["respuesta_correcta"] = respuesta

     # Preguntar al usuario la pregunta elegida
    await update.message.reply_text(pregunta)



    return RESPUESTA



async def check_respuesta(update, context):
    # Obtener la respuesta ingresada por el usuario
    respuesta_usuario = update.message.text

    # Obtener la respuesta correcta guardada en el contexto
    respuesta_correcta = context.user_data["respuesta_correcta"]

    # Comparar la respuesta del usuario con la respuesta correcta
    if respuesta_usuario.lower() == respuesta_correcta:
        mensaje = "¬°Correcto! üéâ"
    else:
        mensaje = "Respuesta incorrecta üòî La respuesta correcta era: " + respuesta_correcta

    # Responder al usuario con el mensaje correspondiente
    await update.message.reply_text(mensaje, reply_markup=markup)


    return CHOOSING


async def recursos(update, context):
    message = "Aqu√≠ hay algunos recursos adicionales para ayudarte a mejorar tus habilidades en el idioma:\n\n" \
              "üìö [Duolingo](https://www.duolingo.com/): Una plataforma de aprendizaje de idiomas en l√≠nea y gratuita.\n\n" \
              "üé• [Netflix](https://www.netflix.com/): Una plataforma de streaming con una gran cantidad de pel√≠culas y series en el idioma que deseas aprender.\n\n" \
              "üéß [LingQ](https://www.lingq.com/): Una aplicaci√≥n que te permite escuchar y leer art√≠culos y libros en el idioma que deseas aprender.\n\n" \
              "üìñ [Librivox](https://librivox.org/): Una plataforma de audiolibros en varios idiomas, incluyendo el que deseas aprender.\n\n" \
              "üé§ [Italki](https://www.italki.com/): Una plataforma de intercambio de idiomas donde puedes conectarte con hablantes nativos del idioma que deseas aprender.\n\n"

    # Enviar el mensaje con los recursos adicionales
    await update.message.reply_text(message, parse_mode=ParseMode.MARKDOWN, reply_markup=markup)

    return CHOOSING

async def echo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Echo the user message."""
    await update.message.reply_text(update.message.text)

async def done(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Display the gathered info and end the conversation."""
    user_data = context.user_data
    if "choice" in user_data:
        del user_data["choice"]

    await update.message.reply_text(
        "Hasta la proxima!",
        reply_markup=ReplyKeyboardRemove(),
    )

    user_data.clear()
    return ConversationHandler.END


def main():
    key = os.getenv('API_KEY')
    dp = Application.builder().token(key).build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            CHOOSING: [
                MessageHandler(filters.Regex("^(Gram√°tica)$"), gramatica),
                MessageHandler(filters.Regex("^(Vocabulario b√°sico)$"), vocabulario),
                MessageHandler(filters.Regex("^(Pr√°ctica)$"), practica),
                MessageHandler(filters.Regex("^(Recursos adicionales)$"), recursos),
                MessageHandler(filters.Regex("^(done)$"), done),
                CallbackQueryHandler(gramatica_options, pattern="^" + "verbos|adjetivos|pronombres|preposiciones|menu" + "$"),
                CallbackQueryHandler(vocabulario_options, pattern="^" + "hola|Buenos d√≠as|Disculpa|¬°Genial!|¬øQu√© hora es?|¬øEn qu√© puedo ayudarte?|Inteligencia artificial|¬øPodr√≠as repetir eso, por favor?" + "$"),
            ],

            RESPUESTA: [
                MessageHandler(filters.TEXT, check_respuesta),

            ],
            TYPING_REPLY: [

            ],
        },
        fallbacks=[MessageHandler(filters.Regex("^Done$"), done)],
    )

    dp.add_handler(conv_handler)

    dp.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, echo))

    # Correr el bot hasta que se presione Ctrl-C
    dp.run_polling()

if __name__ == "__main__":
    main()
